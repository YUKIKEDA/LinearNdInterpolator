#!/usr/bin/env python3
"""
SciPy参照データからC++テストを生成するスクリプト

script/out/scipy_reference_data.jsonを読み込んで、
厳密なC++テストファイルを生成します。
"""

import json
import os
import sys

def load_scipy_reference_data(json_path):
    """SciPy参照データを読み込み"""
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: Reference data file not found: {json_path}")
        return None
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON format: {e}")
        return None

def generate_cpp_test_header():
    """C++テストファイルのヘッダー部分を生成"""
    return '''#include <gtest/gtest.h>
#include "LinearNdInterpolator.h"
#include <cmath>
#include <vector>
#include <limits>
#include <string>
#include <chrono>
#include <sstream>

// Auto-generated SciPy Reference Validation Tests
// Generated from: script/out/scipy_reference_data.json
// DO NOT EDIT THIS FILE MANUALLY - Regenerate using generate_scipy_cpp_tests.py

class SciPyReferenceTest : public ::testing::Test {
protected:
    void SetUp() override {
        exact_tolerance_ = 1e-12;         // For exact vertex matches
        interpolation_tolerance_ = 1e-10; // For linear interpolation (matches C++ implementation)
        loose_tolerance_ = 1e-6;          // For complex cases with numerical instability
        precision_tolerance_ = 1e-9;      // For numerical precision tests
        large_scale_tolerance_ = 1e-8;    // For large coordinate value tests
    }
    
    double exact_tolerance_;
    double interpolation_tolerance_;
    double loose_tolerance_;
    double precision_tolerance_;
    double large_scale_tolerance_;
    
    // Scalar value validation methods
    void validateExactMatch(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point,
        double expected_result
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        EXPECT_NEAR(result, expected_result, exact_tolerance_)
            << "Exact match failed for point [" << formatPoint(query_point) << "]"
            << "\\nExpected: " << expected_result << ", Got: " << result;
    }
    
    void validateInterpolation(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point,
        double expected_result,
        const std::string& test_type = "standard"
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        
        double tolerance = interpolation_tolerance_;
        if (test_type == "loose" || test_type == "random" || test_type == "large") {
            tolerance = loose_tolerance_;
        } else if (test_type == "precision") {
            tolerance = precision_tolerance_;
        } else if (test_type == "large_scale") {
            tolerance = large_scale_tolerance_;
        }
        
        EXPECT_NEAR(result, expected_result, tolerance)
            << "Interpolation failed for point [" << formatPoint(query_point) << "]"
            << "\\nTest type: " << test_type
            << "\\nExpected: " << expected_result << ", Got: " << result
            << "\\nTolerance: " << tolerance;
    }
    
    void validateOutOfHull(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        // Our implementation returns NaN for out-of-hull points (like SciPy)
        EXPECT_TRUE(std::isnan(result))
            << "Out-of-hull point should return NaN, got: " << result
            << " for point [" << formatPoint(query_point) << "]";
    }
    
    // Vector value validation methods
    void validateVectorExactMatch(
        const std::vector<std::vector<double>>& points,
        const std::vector<std::vector<double>>& values,
        const std::vector<double>& query_point,
        const std::vector<double>& expected_result
    ) {
        LinearNdInterpolator interp(points, values);
        std::vector<std::vector<double>> result = interp.interpolate(std::vector<std::vector<double>>{query_point});
        
        ASSERT_EQ(result.size(), 1) << "Expected single result";
        ASSERT_EQ(result[0].size(), expected_result.size()) << "Result dimension mismatch";
        
        for (size_t i = 0; i < expected_result.size(); ++i) {
            EXPECT_NEAR(result[0][i], expected_result[i], exact_tolerance_)
                << "Vector exact match failed at index " << i
                << " for point [" << formatPoint(query_point) << "]"
                << "\\nExpected[" << i << "]: " << expected_result[i]
                << ", Got[" << i << "]: " << result[0][i];
        }
    }
    
    void validateVectorInterpolation(
        const std::vector<std::vector<double>>& points,
        const std::vector<std::vector<double>>& values,
        const std::vector<double>& query_point,
        const std::vector<double>& expected_result,
        const std::string& test_type = "standard"
    ) {
        LinearNdInterpolator interp(points, values);
        std::vector<std::vector<double>> result = interp.interpolate(std::vector<std::vector<double>>{query_point});
        
        ASSERT_EQ(result.size(), 1) << "Expected single result";
        ASSERT_EQ(result[0].size(), expected_result.size()) << "Result dimension mismatch";
        
        double tolerance = interpolation_tolerance_;
        if (test_type == "loose" || test_type == "random" || test_type == "large") {
            tolerance = loose_tolerance_;
        } else if (test_type == "precision") {
            tolerance = precision_tolerance_;
        }
        
        for (size_t i = 0; i < expected_result.size(); ++i) {
            EXPECT_NEAR(result[0][i], expected_result[i], tolerance)
                << "Vector interpolation failed at index " << i
                << " for point [" << formatPoint(query_point) << "]"
                << "\\nTest type: " << test_type
                << "\\nExpected[" << i << "]: " << expected_result[i]
                << ", Got[" << i << "]: " << result[0][i]
                << "\\nTolerance: " << tolerance;
        }
    }
    
    void validateVectorOutOfHull(
        const std::vector<std::vector<double>>& points,
        const std::vector<std::vector<double>>& values,
        const std::vector<double>& query_point
    ) {
        LinearNdInterpolator interp(points, values);
        std::vector<std::vector<double>> result = interp.interpolate(std::vector<std::vector<double>>{query_point});
        
        ASSERT_EQ(result.size(), 1) << "Expected single result";
        
        // All components should be NaN for out-of-hull points
        for (size_t i = 0; i < result[0].size(); ++i) {
            EXPECT_TRUE(std::isnan(result[0][i]))
                << "Out-of-hull point component " << i << " should return NaN, got: " << result[0][i]
                << " for point [" << formatPoint(query_point) << "]";
        }
    }
    
private:
    std::string formatPoint(const std::vector<double>& point) {
        std::ostringstream oss;
        for (size_t i = 0; i < point.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << point[i];
        }
        return oss.str();
    }
    
    std::string formatVector(const std::vector<double>& vec) {
        std::ostringstream oss;
        oss << "[";
        for (size_t i = 0; i < vec.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << vec[i];
        }
        oss << "]";
        return oss.str();
    }
};

'''

def generate_test_case(test_case, test_id):
    """個別のテストケースを生成"""
    name = test_case.get('name', f'TestCase_{test_id}')
    description = test_case.get('description', 'No description')
    
    # C++識別子として有効な名前に変換
    cpp_test_name = name.replace(' ', '_').replace('-', '_').replace('.', '_')
    
    # 入力値の生成 - スカラー値かベクトル値かを判定
    values = test_case.get('input_values', [])
    is_vector_values = False
    
    # より厳密にベクトル値かどうかを判定
    if values and len(values) > 0:
        # 最初の要素がリストで、かつ数値のリストかチェック
        first_value = values[0]
        if isinstance(first_value, list) and len(first_value) > 0:
            # リスト内の要素が全て数値かチェック
            if all(isinstance(x, (int, float)) for x in first_value):
                is_vector_values = True
    
    cpp_code = f'''
// Test Case: {name}
// Description: {description}
// Values Type: {"vector" if is_vector_values else "scalar"}
TEST_F(SciPyReferenceTest, {cpp_test_name}) {{
    std::vector<std::vector<double>> points = {{
'''
    
    # 入力ポイントの生成
    for point in test_case.get('input_points', []):
        point_str = ', '.join([f'{coord:.10f}' for coord in point])
        cpp_code += f'        {{{point_str}}},\n'
    
    cpp_code += '    };\n\n'
    
    if is_vector_values:
        # ベクトル値の場合
        cpp_code += '    std::vector<std::vector<double>> values = {\n'
        for value_vec in values:
            value_str = ', '.join([f'{val:.10f}' for val in value_vec])
            cpp_code += f'        {{{value_str}}},\n'
        cpp_code += '    };\n\n'
    else:
        # スカラー値の場合
        values_str = ', '.join([f'{val:.10f}' for val in values])
        cpp_code += f'    std::vector<double> values = {{{values_str}}};\n\n'
    
    # テストタイプの判定
    test_type = determine_test_type(name)
    
    # クエリのテスト生成
    queries = test_case.get('queries', [])
    
    for i, query in enumerate(queries):
        query_point = query.get('query_point', [])
        result = query.get('result')
        
        query_str = ', '.join([f'{coord:.10f}' for coord in query_point])
        
        cpp_code += f'    // Query {i+1}\n'
        
        if result is None:
            # Out-of-hull point (SciPy returns NaN)
            if is_vector_values:
                cpp_code += f'    validateVectorOutOfHull(points, values, {{{query_str}}});\n\n'
            else:
                cpp_code += f'    validateOutOfHull(points, values, {{{query_str}}});\n\n'
        else:
            # 頂点の完全一致かどうかを判定
            is_exact_vertex = is_vertex_match(query_point, test_case.get('input_points', []))
            
            if is_vector_values:
                # ベクトル値補間
                if isinstance(result, list) and len(result) > 0:
                    # SciPyの結果が二重にネストされている場合を処理
                    if len(result) == 1 and isinstance(result[0], list):
                        actual_result = result[0]  # [[0.0, 0.0]] -> [0.0, 0.0]
                    elif all(isinstance(x, (int, float)) for x in result):
                        actual_result = result     # [0.0, 0.0] (既に正しい形式)
                    else:
                        # 不正なデータ形式の場合
                        cpp_code += f'    // ERROR: Invalid vector result format: {result}\n'
                        cpp_code += f'    // validateVectorOutOfHull(points, values, {{{query_str}}});\n\n'
                        continue
                    
                    # 数値のリストかどうか最終確認
                    if isinstance(actual_result, list) and all(isinstance(val, (int, float)) for val in actual_result):
                        result_str = ', '.join([f'{val:.10f}' for val in actual_result])
                        if is_exact_vertex:
                            cpp_code += f'    validateVectorExactMatch(points, values, {{{query_str}}}, {{{result_str}}});\n\n'
                        else:
                            cpp_code += f'    validateVectorInterpolation(points, values, {{{query_str}}}, {{{result_str}}}, "{test_type}");\n\n'
                    else:
                        # 不正なデータ形式
                        cpp_code += f'    // ERROR: Invalid processed vector data: {actual_result}\n'
                        cpp_code += f'    // validateVectorOutOfHull(points, values, {{{query_str}}});\n\n'
                else:
                    # エラーケース：ベクトル値が期待されるがスカラー値が返された
                    cpp_code += f'    // ERROR: Expected vector result but got: {result} (type: {type(result)})\n'
                    cpp_code += f'    // validateVectorOutOfHull(points, values, {{{query_str}}});\n\n'
            else:
                # スカラー値補間
                if isinstance(result, (int, float)):
                    if is_exact_vertex:
                        cpp_code += f'    validateExactMatch(points, values, {{{query_str}}}, {result:.10f});\n\n'
                    else:
                        cpp_code += f'    validateInterpolation(points, values, {{{query_str}}}, {result:.10f}, "{test_type}");\n\n'
                else:
                    # エラーケース：スカラー値が期待されるがベクトル値が返された
                    cpp_code += f'    // ERROR: Expected scalar result but got vector: {result}\n'
                    cpp_code += f'    // validateOutOfHull(points, values, {{{query_str}}});\n\n'
    
    cpp_code += '}\n'
    
    return cpp_code

def determine_test_type(test_name):
    """テスト名からテストタイプを判定"""
    name_lower = test_name.lower()
    
    if 'precision' in name_lower:
        return 'precision'
    elif 'large_scale' in name_lower or 'large' in name_lower:
        return 'large_scale'
    elif 'random' in name_lower or 'complex' in name_lower:
        return 'random'
    elif 'boundary' in name_lower or 'edge' in name_lower:
        return 'precision'  # 境界テストは高精度が必要
    elif any(dim in name_lower for dim in ['5d', '6d', '7d', '8d', '9d']):
        return 'loose'  # 高次元は数値誤差が大きい
    else:
        return 'standard'

def is_vertex_match(query_point, input_points, tolerance=1e-12):
    """クエリポイントが入力頂点と一致するかチェック"""
    for point in input_points:
        if len(query_point) == len(point):
            match = True
            for i in range(len(query_point)):
                if abs(query_point[i] - point[i]) > tolerance:
                    match = False
                    break
            if match:
                return True
    return False

def generate_cpp_test_file(reference_data, output_path):
    """完全なC++テストファイルを生成"""
    
    cpp_content = generate_cpp_test_header()
    
    test_cases = reference_data.get('test_cases', [])
    
    for i, test_case in enumerate(test_cases):
        cpp_content += generate_test_case(test_case, i + 1)
    
    # ファイルの終端
    cpp_content += '\n// End of auto-generated tests\n'
    
    # ファイルに書き込み
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(cpp_content)
        return True
    except Exception as e:
        print(f"Error writing C++ test file: {e}")
        return False

def main():
    """メイン処理"""
    print("SciPy Reference Data to C++ Test Generator")
    print("=" * 50)
    
    # 入力ファイルパス
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(script_dir)
    json_path = os.path.join(project_root, 'script', 'out', 'scipy_reference_data.json')
    
    print(f"Looking for reference data: {json_path}")
    
    # 参照データの読み込み
    reference_data = load_scipy_reference_data(json_path)
    if reference_data is None:
        print("Failed to load reference data. Exiting.")
        return 1
    
    test_cases = reference_data.get('test_cases', [])
    print(f"Loaded reference data with {len(test_cases)} test cases")
    
    # 出力ファイルパス  
    output_path = os.path.join(project_root, 'tests', 'test_scipy_reference_auto_generated.cpp')
    
    print(f"Generating C++ test file: {output_path}")
    
    # C++テストファイルの生成
    if generate_cpp_test_file(reference_data, output_path):
        print("Successfully generated C++ test file!")
        
        # 詳細統計情報
        total_queries = sum(len(tc.get('queries', [])) for tc in test_cases)
        
        print("\\n" + "=" * 40)
        print("DETAILED STATISTICS")
        print("=" * 40)
        print(f"✓ Total test cases: {len(test_cases)}")
        print(f"✓ Total queries: {total_queries}")
        
        # 次元統計
        space_dimensions = set()
        value_dimensions = set()
        vector_test_count = 0
        scalar_test_count = 0
        
        for tc in test_cases:
            points = tc.get('input_points', [])
            values = tc.get('input_values', [])
            
            if points:
                space_dimensions.add(len(points[0]))
            
            if values:
                if isinstance(values[0], list):
                    value_dimensions.add(len(values[0]))
                    vector_test_count += 1
                else:
                    value_dimensions.add(1)
                    scalar_test_count += 1
        
        print(f"✓ Space dimensions: {sorted(space_dimensions)}")
        print(f"✓ Value dimensions: {sorted(value_dimensions)}")
        print(f"✓ Scalar value tests: {scalar_test_count}")
        print(f"✓ Vector value tests: {vector_test_count}")
        
        # テストタイプ別統計
        test_type_counts = {}
        out_of_hull_count = 0
        
        for tc in test_cases:
            test_type = determine_test_type(tc.get('name', ''))
            test_type_counts[test_type] = test_type_counts.get(test_type, 0) + 1
            
            for query in tc.get('queries', []):
                if query.get('result') is None:
                    out_of_hull_count += 1
        
        print("\\nTest Type Distribution:")
        for test_type, count in sorted(test_type_counts.items()):
            print(f"  - {test_type}: {count} test cases")
        
        print("\\nQuery Type Distribution:")
        print(f"  - In-hull queries: {total_queries - out_of_hull_count}")
        print(f"  - Out-of-hull queries: {out_of_hull_count}")
        
        # テストケース名一覧
        print("\\nGenerated Test Cases:")
        for i, tc in enumerate(test_cases, 1):
            name = tc.get('name', f'TestCase_{i}')
            points = tc.get('input_points', [])
            values = tc.get('input_values', [])
            queries = tc.get('queries', [])
            
            dim_info = f"{len(points[0])}D" if points else "?D"
            val_info = "vector" if values and isinstance(values[0], list) else "scalar"
            test_type = determine_test_type(name)
            
            print(f"  {i:2}. {name}")
            print(f"      [{dim_info}, {val_info}, {test_type}, {len(queries)} queries]")
        
        print("\\n" + "=" * 40)
        print("ENHANCED FEATURES")
        print("=" * 40)
        print("✓ Vector value interpolation support")
        print("✓ High-dimensional tests (5D-7D)")
        print("✓ Numerical precision tests (1e-10 tolerance)")
        print("✓ Boundary condition tests")
        print("✓ Large-scale coordinate tests")
        print("✓ Adaptive tolerance based on test type")
        print("✓ Out-of-hull NaN validation")
        
        print("\\n" + "=" * 40)
        print("NEXT STEPS")
        print("=" * 40)
        print("1. Build the project:")
        print("   mkdir -p build && cd build")
        print("   cmake .. && make")
        print("")
        print("2. Run the tests:")
        print("   ctest --verbose")
        print("   # or")
        print("   ./tests/test_scipy_reference_auto_generated")
        print("")
        print("3. Check specific test categories:")
        print("   ctest -R SciPyReferenceTest")
        
        return 0
    else:
        print("Failed to generate C++ test file.")
        return 1

if __name__ == "__main__":
    sys.exit(main())