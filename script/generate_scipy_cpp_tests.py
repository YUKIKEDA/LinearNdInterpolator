#!/usr/bin/env python3
"""
SciPy参照データからC++テストを生成するスクリプト

script/out/scipy_reference_data.jsonを読み込んで、
厳密なC++テストファイルを生成します。
"""

import json
import os
import sys

def load_scipy_reference_data(json_path):
    """SciPy参照データを読み込み"""
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: Reference data file not found: {json_path}")
        return None
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON format: {e}")
        return None

def generate_cpp_test_header():
    """C++テストファイルのヘッダー部分を生成"""
    return '''#include <gtest/gtest.h>
#include "LinearNdInterpolator.h"
#include <cmath>
#include <vector>
#include <limits>
#include <string>
#include <chrono>

// Auto-generated SciPy Reference Validation Tests
// Generated from: script/out/scipy_reference_data.json
// DO NOT EDIT THIS FILE MANUALLY - Regenerate using generate_scipy_cpp_tests.py

class SciPyReferenceTest : public ::testing::Test {
protected:
    void SetUp() override {
        exact_tolerance_ = 1e-12;  // For exact vertex matches
        interpolation_tolerance_ = 1e-10;  // For linear interpolation
        loose_tolerance_ = 1e-6;   // For complex cases with numerical instability
    }
    
    double exact_tolerance_;
    double interpolation_tolerance_;
    double loose_tolerance_;
    
    void validateExactMatch(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point,
        double expected_result
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        EXPECT_NEAR(result, expected_result, exact_tolerance_)
            << "Exact match failed for point [" << formatPoint(query_point) << "]";
    }
    
    void validateInterpolation(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point,
        double expected_result,
        bool use_loose_tolerance = false
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        double tolerance = use_loose_tolerance ? loose_tolerance_ : interpolation_tolerance_;
        EXPECT_NEAR(result, expected_result, tolerance)
            << "Interpolation failed for point [" << formatPoint(query_point) << "]\\n"
            << "Expected: " << expected_result << ", Got: " << result;
    }
    
    void validateOutOfHull(
        const std::vector<std::vector<double>>& points,
        const std::vector<double>& values,
        const std::vector<double>& query_point
    ) {
        LinearNdInterpolator interp(points, values);
        double result = interp.interpolate(query_point);
        // Our implementation returns nearest neighbor for out-of-hull points
        // SciPy returns NaN, but we expect finite values
        EXPECT_TRUE(std::isfinite(result))
            << "Out-of-hull point should return finite value, got: " << result
            << " for point [" << formatPoint(query_point) << "]";
        EXPECT_FALSE(std::isnan(result))
            << "Our implementation should not return NaN";
    }
    
private:
    std::string formatPoint(const std::vector<double>& point) {
        std::string result;
        for (size_t i = 0; i < point.size(); ++i) {
            if (i > 0) result += ", ";
            result += std::to_string(point[i]);
        }
        return result;
    }
};

'''

def generate_test_case(test_case, test_id):
    """個別のテストケースを生成"""
    name = test_case.get('name', f'TestCase_{test_id}')
    description = test_case.get('description', 'No description')
    
    # C++識別子として有効な名前に変換
    cpp_test_name = name.replace(' ', '_').replace('-', '_').replace('.', '_')
    
    cpp_code = f'''
// Test Case: {name}
// Description: {description}
TEST_F(SciPyReferenceTest, {cpp_test_name}) {{
    std::vector<std::vector<double>> points = {{
'''
    
    # 入力ポイントの生成
    for point in test_case.get('input_points', []):
        point_str = ', '.join([f'{coord:.10f}' for coord in point])
        cpp_code += f'        {{{point_str}}},\n'
    
    cpp_code += '    };\n\n'
    
    # 入力値の生成
    values = test_case.get('input_values', [])
    values_str = ', '.join([f'{val:.10f}' for val in values])
    cpp_code += f'    std::vector<double> values = {{{values_str}}};\n\n'
    
    # クエリのテスト生成
    queries = test_case.get('queries', [])
    
    for i, query in enumerate(queries):
        query_point = query.get('query_point', [])
        result = query.get('result')
        
        query_str = ', '.join([f'{coord:.10f}' for coord in query_point])
        
        cpp_code += f'    // Query {i+1}\n'
        
        if result is None:
            # Out-of-hull point (SciPy returns NaN)
            cpp_code += f'    validateOutOfHull(points, values, {{{query_str}}});\n\n'
        else:
            # 頂点の完全一致かどうかを判定
            is_exact_vertex = is_vertex_match(query_point, test_case.get('input_points', []))
            
            if is_exact_vertex:
                cpp_code += f'    validateExactMatch(points, values, {{{query_str}}}, {result:.10f});\n\n'
            else:
                # 複雑な計算かどうかを判定（ランダムデータの場合など）
                use_loose = 'Random' in name or 'Complex' in name or 'Large' in name
                if use_loose:
                    cpp_code += f'    validateInterpolation(points, values, {{{query_str}}}, {result:.10f}, true);\n\n'
                else:
                    cpp_code += f'    validateInterpolation(points, values, {{{query_str}}}, {result:.10f});\n\n'
    
    cpp_code += '}\n'
    
    return cpp_code

def is_vertex_match(query_point, input_points, tolerance=1e-12):
    """クエリポイントが入力頂点と一致するかチェック"""
    for point in input_points:
        if len(query_point) == len(point):
            match = True
            for i in range(len(query_point)):
                if abs(query_point[i] - point[i]) > tolerance:
                    match = False
                    break
            if match:
                return True
    return False

def generate_cpp_test_file(reference_data, output_path):
    """完全なC++テストファイルを生成"""
    
    cpp_content = generate_cpp_test_header()
    
    test_cases = reference_data.get('test_cases', [])
    
    for i, test_case in enumerate(test_cases):
        cpp_content += generate_test_case(test_case, i + 1)
    
    # ファイルの終端
    cpp_content += '\n// End of auto-generated tests\n'
    
    # ファイルに書き込み
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(cpp_content)
        return True
    except Exception as e:
        print(f"Error writing C++ test file: {e}")
        return False

def main():
    """メイン処理"""
    print("SciPy Reference Data to C++ Test Generator")
    print("=" * 50)
    
    # 入力ファイルパス
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(script_dir)
    json_path = os.path.join(project_root, 'script', 'out', 'scipy_reference_data.json')
    
    print(f"Looking for reference data: {json_path}")
    
    # 参照データの読み込み
    reference_data = load_scipy_reference_data(json_path)
    if reference_data is None:
        print("Failed to load reference data. Exiting.")
        return 1
    
    print(f"Loaded reference data with {len(reference_data.get('test_cases', []))} test cases")
    
    # 出力ファイルパス
    output_path = os.path.join(script_dir, 'test_scipy_reference_auto_generated.cpp')
    
    print(f"Generating C++ test file: {output_path}")
    
    # C++テストファイルの生成
    if generate_cpp_test_file(reference_data, output_path):
        print("Successfully generated C++ test file!")
        
        # 統計情報
        test_cases = reference_data.get('test_cases', [])
        total_queries = sum(len(tc.get('queries', [])) for tc in test_cases)
        
        print("\\nStatistics:")
        print(f"- Test cases: {len(test_cases)}")
        print(f"- Total queries: {total_queries}")
        
        # 次元統計
        dimensions = set()
        for tc in test_cases:
            points = tc.get('input_points', [])
            if points:
                dimensions.add(len(points[0]))
        
        print(f"- Dimensions: {sorted(dimensions)}")
        
        print("\\nNext steps:")
        print("1. Add the generated test file to CMakeLists.txt")
        print("2. Build and run tests with: cmake --build build && ctest")
        
        return 0
    else:
        print("Failed to generate C++ test file.")
        return 1

if __name__ == "__main__":
    sys.exit(main())